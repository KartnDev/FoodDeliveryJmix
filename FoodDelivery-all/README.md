# Self-Contained Systems под микроскопом

Как быстро зафейлить новый проект Java? Просто взять и применить все, что ты услышал на последней Java конференции;) 
Как быстро сделать энтерпрайзный проект минимальной командой в короткие сроки? 
Верно - подобрать оптимальную архитектуру и правильные инструменты. 
Сегодня расскажу о компромиссном варианте между хайповыми (все еще) **микросервисами** и **монолитами**, который называется [Self-Contained Systems](https://scs-architecture.org/)
Кажется, он выпьет меньше крови и сохранит ваши нервы. Ну обо всем по порядку.

Отмечу, что **Self-Contained Systems** мы будем называть их автономные системы или кратко - SCS.

![architecture-choose.png](public/architecture-choose.png)

Следуя из названия, принцип подхода прост - **разбиваем систему по доменам**, в каждом домене находится независимый монолит(система).
Стараемся максимально не допускать связность между подсистемами.
Надпоминает микросервисы?
Но не делайте поспешных выводов!

Пройдя "вьетнам" на одном энтерпрайс проекте с SCS подобной архитектурой, я захотел сделать R&D по автономным системам.
Хотелось бы поделиться опытом исследований и рассказать как готовить SCS. 
Какой спектр задач может покрыть новоявленная концепция и к каким кейсам применить SCS станет для проекта идеальным решением?

### Для кого это может быть актуально?
Очевидно, в бигтехе - сбере, озоне, втб и других явова (см. [ЯВОВА/ВОТВАСЯ](https://habr.com/ru/articles/586426/)) 
все архитекторы будут воротить нос, как только услышат слово монолит. 

**В первую очередь**, SCS, как и сама статья будет интересна людям, занимающимся **E-commerce** приложениями. 
Насмотревшись на кровавый энтерпрейс, могу сказать, если у вас скудный ресурс, а система большая, то SCS может стать целебной таблеткой, решающей 
многие проблемы среднестатистического проекта.
**Вторая часть аудитории** - проекты, использующие современные фуллстак фреймворки. 
Я, как разработчик фреймворка `Jmix`, а так же любитель `Ruby on Rails`, могу заявить, что написание SCS будет для вас занимательным опытом 
(ну или хотя бы прочтение данной статьи станет занимательным процессом для вас).

### Как я узнал о SCS
Как-то на одном из дейликов или планерок, мы с коллегами <s>подняли срач</s> дискутировали на тему **таргет аудитории** [Jmix](https://www.jmix.ru/). 
Можно ли написать огромный маркетплейс без колоссальных усилий на платформе?
А так как я уже знал ответ на этот вопрос, пройдя медные трубы в кровавом энтерпрайсе, у меня возникла мысль
написать **демо-проект**, который будет неким стендом, **чего можно добиться используя монолиты в 24 году** (_куда большего,
чем вы могли бы представить_).

## **Self Contained Systems – ключ к модульной архитектуре**
Индикатор того, что **ваш проект будет хорошо ложиться на SCS** - **больше количество доменов, бизнес логики и большое количество кода для форм (html form)**.
Узнали? Это же наш (не)любимый энтерпрайс. **Главный плюс**, который проект получает при разделении на автономные системы - это
_"микросервисные монолиты"_. В таком подходе мы имеем **повышенную устойчивость**, **деплой** и другие плюшки, о которых я расскажу далее.

<img alt="scs-architecture-start.png" height="50%" src="public/scs-architecture-start.png" width="50%"/>

### Детальное погружение

_Если говорить ~~душно~~ более научно, то_:
> **Self Contained Systems** — это независимые, самодостаточные и слабосвязанные системы (подсистемы), 
каждый из которых представляет собой отдельную часть функциональности в рамках большого программного продукта.


Перейдем на простонародный язык.
**Автономные системы** это "_сообщающиеся монолиты_" с некоторым количеством "_но_" заимствованных из микросервисов.
**SCS** - это набор монолитов, написанных в SOA стиле и разбитых по доменам с минимальной связанность и
отказоустойчивыми межсистемными коммуникациями.

Ключевой особенностью таких систем является то, что **они реализуют специфический бизнес-процесс или набор связанных
функций** и обладают всем необходимым для их работы: кодом, данными, конфигурацией и зависимостями.
При этом каждая система **минимально связана**, может быть разработана, развернута, заменена или **удалена независимо** от остальных частей большой
системы.

### Когда не стоит смотреть в сторону SCS?
Ну... Если у вас **большая нагрузка** (в основном это касается UI), сложный UI, который проще написать на современных
фронтенд фреймворках с использованием SOA/микросервисов. В общем, если у вас не стандартный UI - вы можете наесться "_проблем_".
Если в проекте **какие-то вычисления** или **риал-тайм данные**, проще будет сразу писать микросервисы. 
**Итого**: все перечисленные выше проблемы обычно не касаются энтерпрайса.

### У самурая нет ~~плана~~ архитектуры - есть только ~~путь~~ задачи!
**DISCLAIMER!**
В **правильных руках** и монолит может стать крайне эффективной архитектурой(см. GitHub, GitLab, Shopify).
Не относитесь к статье как к постулатам. Зачастую, **выбор архитектуры может быть делом вкуса и скиллов команды.**

### Innoq
**Innoq** - пожалуй, самый большой мейинейнер в комьюнити SCS.
Если перейти по [ссылке](https://www.innoq.com/en/cases/best-in-industry-e-commerce-plattform-fuer-elektronikkomponenten/),
можно почитать историю об успешном успехе Innoq, построившие свою _E-Commerce систему_ на базе Self-Contained Systems.
Скриншот ниже, взятый с сайта Innoq, примерно знакомит нас с архитектурой SCS. 

![scs-example.png](public/scs-example.png)

Как мы можем наблюдать, каждая из подсистем innoq - это набор монолитов, разбитых на домены.
Подмечу, есть общая система, которая собирает все разрозненные элементы UI вместе.

Чтобы лучше прочувствовать разницу между SOA и микросервисами, я добавил картинку ниже,
демонстрирующую разницу в этих подходах.

<img alt="architecture-comparation.png" height="67%" width="67%" src="public/architecture-comparation.png" />

## Философия Self-Contained Systems!

![phylo.png](public/phylo.png)

Сообщество энтузиастов сформулировали некоторое количество **принципов**, следуя которым, можно написать **хорошую
систему**, построенную на SCS. _На самом сайте SCS про них можно детально почитать_. 

### Основные принципы:
**Ниже находится пересказ всех поинтов, описанных комьюнити и Innoq**. 

_От себя добавил некоторые недосказанные поинты, а где-то добавил комментарии.
Здесь не будет никаких искажений оригинала, лишь объяснения. 
Мое мнение о работе SCS в реальном мире я выскажу чуть позже._

* **Доменное разбиение**: Важнейшей составляющей SCS является разбиение системы на домены. Каждый _домен представляет
  собой независимую подсистему_, сосредотачивающуюся на своей области ответственности.
* **Сосредоточенность на домене**: Желательно, чтобы каждая система не выносила и не привносила свои внутренние
  объекты за границы ответственности своей же области.
* **Минимизация оверхеда**: Каждая _подсистема должны выглядеть как микросервис_ с архитектурной точки зрения.
* **Сервисность**: Допускается использование `микросервисов` для решения `доменной бизнес логики` (для одной системы
  использование n микросервисов в бекенде).
* **Отдельная база данных**: Каждая система, подобно микросервисам, обязана иметь свою собственную базу данных.
* **Технологическая свобода**: Отсутствие ограничений в выборе технологий позволяет адаптировать подход к конкретным
  потребностям проекта.
* **Асинхронные коммуникации**: Коммуникации между системами должны быть `асинхронными`. Это обеспечивает более
  эффективное взаимодействие и гибкость. Межсистемные коммуникации должны использовать `HTTP Rest` или `легковесный брокер`
  сообщений.
* **Сосредоточенность команд**: Одна команда может работать над одной или несколькими подсистемами. Над одной
  подсистемой может работать ТОЛЬКО одна команда.
* **Минимизация связности**: Уровень связности между системами должен быть минимальным, обеспечивая тем самым легкость
  поддержки и модификации.
* **Переиспользуемость**: Над всеми системами существуют проект или проекты, вобравшие в себя все общие от систем.
  Общие UI компоненты, общие сущности и DTO, API подсистем, которые вынесены наружу,
  общие вычисления, подходы. _Пример - общий Oidc плагин для работы с Keycloak_.
* **Отдельный UI**: Каждая система имеет свой собственный UI, который должен синергировать по стилю с другими системами.
  Синергия должна достигаться по средствам общего `UI Toolkit`.
* **Слияние**: Все подсистемы с точки зрения `UI/UX` должны выглядеть как одно целое. Излишние сообщения между системами
  должны уменьшаться по средствам использования `Web интерфейсов`, таких как `hyperlink`, `iframe` и те.
* **Обобщенный UI**: При использовании `iframe` должен быть `root-layout система`, которая объединяет все подсистемы в один UI.
* **Связанный UI**:При использовании hyperlink-ов, они обязаны работать в ОБЕ стороны.

### Ключевые аспекты философии:
_Ниже комментарии, которые пояснят некоторую недосказанность философии Self-Contained Systems._

* **Логическое разбиение системы на домены** <br/>
    В зависимости от области, где функционирует система, **SCS может принимать различные формы**.
    Соблюдение указанных выше принципов **рекомендуется**, но также зависит от конкретной доменной области.

* **Автономность систем и подход к коммуникациям**. <br/>
    При переходе от общего к частному следует **внимательно** взвешивать, принимая во внимание **потребности
    конкретного проекта**. Проблема коммуникаций: как бы ни топило комьюнити за асинхронные коммуникации,
    **это не всегда доступно или целесообразно**.
    Например, в моем демо не было **явных** асинхронных коммуникаций.
    Такая уж доменная область. 
    Если так сильно хочется асинхронные коммуникации, то лучше воспользоваться **брокером сообщений**.

* **Связность и использование iframe**. <br/>
    Третий аспект касается связности между системами, UI и **применения iframe**. В зависимости от требований проекта, системы
    могут содержать **разное количество iframe** или вовсе **обходиться без них**.
    То же касается и общего `UI Toolkit`, `Root layout service` и других пунктов, связных с UI. 
    **Главное** - в автономных системах вероятно **проектирование UX/UI будет более сложной задачей**, чем проектирование
    коммуникаций.

* **Использование фреймворков**. <br/>
    Так как мы используем наши любимые фреймворки в построении подсистем, то у нас есть доступ к всем их плюшкам. Однако,
    отсюда и вытекает один интересный момент, что при использовании монолитных фреймворков,
    вас поощряют за написание сложных систем со сложной бизнес логикой, вследствие чего, отдельная система редко получается
    действительно по размерах подходящей к термину "микро" сервис.

## Плюсы, минусы и цели архитектуры

Теперь обсудим что мы получаем, выбрав SCS. На какие грабли мы можем наступить в таком подходе?

### Плюсы:

* **Отказоустойчивость**: Автономные системы обеспечивают устойчивость, поскольку сбои в одной системе не влияют на
  остальные.
* **Простое разделение по командам**: Каждая подсистема может быть независимо разрабатываемой и поддерживаемой командой,
  что способствует гибкости в управлении проектом.
* **Сервисная ориентированность**: SCS способствует созданию сервисно-ориентированных систем, где каждая часть выполняет
  конкретные функции.
* **Преимущества монолитов**: Архитектура сохраняет выгоды монолитов, такие как скорость разработки, возможность
  использования любимых фреймворков, а также наличие фуллстек UI и ORM.
* **Независимый деплой**: Возможность обновлять и масштабировать каждую подсистему независимо, что упрощает управление
  версиями и обеспечивает гибкость в развертывании.
* **Предпочтительное решение для энтерпрайса**: В некоторых случаях SCS может представлять собой более выгодное решение для
  энтерпрайса, чем микросервисы, благодаря более простому управлению и большей схожести с монолитами.

### Минусы

* **Разделенный UI**: Необходимость долгого проектирования коммуникаций и пользовательского интерфейса между автономными
  подсистемами.
* **Усложненные коммуникации**: В сравнении с монолитом требуется более тщательное проектирование и внимание к
  взаимодействию между системами.
* **Усложненный деплой**: Процессы развертывания становятся более сложными по сравнению с монолитной архитектурой.
* **Дополнительная документация и взаимодействие команд**: Вводится дополнительная необходимость в документировании и
  согласовании работы между различными командами, что может потребовать дополнительных ресурсов.
* **UI Toolkit**: Необходимость выделения времени на согласование общего набора инструментов для пользовательского
  интерфейса.
* **Невозможность ускорения UI**: В отличие от выноса бизнес-логики, ускорение пользовательского интерфейса может
  оказаться более сложной и дорогостоящей задачей.

### Минусы в реалиях энтерпрайса

Однако все эти недостатки могут быть **менее релевантными** для **B2B** и **E-Commerce** систем, где количество пользователей
вторично по сравнению с множеством бизнес-процессов и объемом бизнес-логики.

## Back to reality: Демо-пример и выбор объектной модели

Той еще проблемой для меня стал выбор темы демо. CRM? Пэт-клиника? Онлайн магазин? Public Cloud?
Ох, вы бы знали сколько я думал над тем, что же выбрать... 
В итоге, взвесив все плюсы и минусы, я решил, что мой выбор - **доставка еды**.
Эта тема не только предоставляет широкий спектр бизнес-процессов, но и близка к повседневной реальности аудитории.
Ну кто хоть раз не пользовался доставкой еды? 
И понять легко и бизнес-процесс прозрачный и большой;)

### План работ
Раз с темой разорались, пора переходить к планированию. В выбранной области стоит выделить:
* Домены
* Сущности и отношения между ними
* Флоу\процессы
* Правила и констреинты

Далее **опустим некоторое количество правил**, которые нам будут сильно усложнять работу. Обычно такие правила являются 
жизненно важными для бизнеса, но с хай-левел точки зрения являются **мелочами**. Например - мы не будем обрабатывать случай,
когда курьер подскользнулся на льду и расшибся:)

### Доставка еды
Пожалуй, иконка проекта выбрана.
А может мне стоило попросить DALL-e сгенерировать ее вместо меня...
Кстати, на иконке спойлеры =)
![img.png](public/food-delivery-icon.png)

Пора выбрать основные домены внутри доставки еды, без которых понятие доставки не может работать.

### Ресторан (Restaurant System):
В этом домене фокусируется вся информация о **ресторанах**.
Здесь осуществляется **регистрация** и **создание** новых ресторанов.
Администраторы ресторанов имеют возможность **настраивать меню, добавлять и редактировать блюда**, а также **принимать заказы**
на готовку еды.
Этот домен является ключевым для организации бизнес-процесса внутри ресторанов.

### Доставка (Delivery):
Домен доставки фокусируется на **управлении курьерами**. Здесь происходит **регистрация курьеров**, назначение им роли
доставщика, а также менеджмент заказов, связанных с доставкой.
В этом домене осуществляется эффективное управление логистикой и выполнением заказов.

### Заказы (Order System):
**Центральным доменом** в системе доставки еды является **система заказов**. Здесь пользователи начинают **бизнес-процесс,
создавая заказы.**
Интерфейс для создания заказов, наполнение корзины и все запросы, связанные с бизнес-процессом доставки еды, исходят
именно из этого домена.
Здесь происходит **взаимодействие с другими подсистемами** и интеграции для эффективного выполнения заказов.

### Важное отступление перед демо:

В **реальной системе** должны существовать дополнительные домены, без которых доставка не имеет смысла.
Эти домены включают **систему платежей**, **уведомлений**, **построения маршрутов** доставки и триггеров геолокации.
Они представляют собой **важные аспекты реальной системы**, но в рамках демонстрации SCS мы **упростим структуру** и
**сфокусируемся на интеграциях** между основными подсистемами.

Перед проведением демо Self-Contained Systems я решил упростить некоторые аспекты бизнес-процесса доставки
еды.
Мы **не будем рассматривать сложные сценарии**, такие как **оплата** и **отмена заказов**, чтобы **минимизировать сложность** написания
кода и ускорить прототипирование проекта.
**Роли будут минимальными** для удобства работы, и мы учтем другие аспекты, которые упростят и ускорят процесс написания
доставки еды.
_Наша основная цель - продемонстрировать эффективные интеграции между различными подсистемами._

### Штош... Далее идем по шагам

1. **Flow-диаграмма и архитектура:** <br/>
   Начнем с создания Flow-диаграммы и определения архитектуры проекта. Это поможет нам лучше понять взаимодействие между
   системами.
2. **Выбор технологического Стека:**<br/>
   На основе Flow-диаграммы мы определимся с технологическим стеком. Какие инструменты и языки программирования будем
   использовать. Хотя спойлеры вы выше видели.
3. **Пробежимся по коду:**<br/>
   Ну как статья может быть и без кода... Такого быть не может. Если кто-то утверждает обратное - да на кол его! Если без шуток,
    то в этом пункте я укажу главные куски кода отвечающие за интеграции между системами, да и то ввиде скрывающихся деталей.
    Если хотите полный проект - я оставил ссылку на [Github репозиторий](https://github.com/KartnDev/FoodDeliveryJmix).
4. **Переход к демонстрации:**<br/>
   Быстро пробежимся по результату, которого мы добились.

### Взглянем на систему с высока

У нас есть три ключевые подсистемы и три типа пользователей.

Подсистемы:

* **Система Заказов (Order System)**: Взаимодействие с пользователями.
* **Система Курьеров (Courier System)**: Ориентирована на курьеров.
* **Система Ресторанов (Restaurant System)**: Администрирование ресторанов.

### Пользователи и тех. решение

1. **Сквозные роли:** <br/>
   **В данной объектной области использование сквозных ролей** представляется **эффективным решением**.
   В системе заказов, каждый пользователь, заходящий в систему, способен сделать заказ.
   Однако, с технической точки зрения, администратор ресторана,
   также входящий в эту систему, может иметь ссылки на продукцию своего ресторана.
   Это позволяет **избежать дублирования ролей** и использовать единую роль для упрощения взаимных ссылок и контента.
   Стоит отметить, что в большинстве других объектных областей сквозная ролевая система может быть неудачным выбором.

2. **Роли и пермишены:**
   Для доступа к другим системам пользователь должен обладать соответствующими ролями.
   Однако, для удобства, **я решил использовать одну единственную роль**,
   предоставляя пользователю необходимые пермишены для взаимодействия с другими системами.
   Это решение сокращает количество ролей, **упрощая дальнейшую разработку демо проекта**.

### Flow-диаграмма и BPMN

Ниже представлена **Flow-диаграмма** того, что будет происходить в системе.
Да. Она немножечко страшная;) А вы видели простые Flow-диаграммы?

Стоит сделать отступление, что будет еще **один шаг**, который мы **опустим**.
Это шаг самой **физической доставки курьером** от точки А до точки Б.
Вместо этого мы просто подождем 10 секунд и сразу поменяем статус заказа на "доставлен".
<details>
  <summary>Flow Diagram</summary>

![scs-food-delivery-flowdiagram.png](public/scs-food-delivery-flowdiagram.png)

</details>

Для **более наглядного представления** мы решили вместо Flow-диаграммы использовать более высокоуровневую BPMN-диаграмму,
которую мы будем использовать в рамках проекта.

![bpmn-food-delivery.png](public/bpmn-food-delivery.png)

Это более интуитивное представление процесса. В общих чертах, мы создали простой сценарий:

1. **Пользователь заходит в систему заказов.**
   Система заказов загружает список ресторанов из системы ресторанов (какая-то тавтология).
2. **Пользователь выбирает ресторан.**
   Система загружает из системы ресторанов список еды и меню для пользователя. Пользователь составляет корзину из
   предложенного и сохраняет заказ.
3. **Система заказов сохраняет копии заказа пользователя и запускает бизнес-процесс.**
4. **Система заказов делает HTTP-запрос в систему ресторанов с запросом на готовку еды.**
   Процесс останавливается и ожидает, пока ресторан подтвердит.
5. **Админ ресторана заходит в систему (ресторанов), берет заказ на приготовление еды.**
   Система ресторанов делает обратный HTTP-запрос в систему доставки еды. Система заказов продолжает бизнес-процесс.
6. **Система заказов делает HTTP-запрос в систему ресторанов курьеров и публикует запрос на доставку.**
7. **Курьер заходит в систему доставки, берет на себя текущий заказ.**
   Система курьеров делает обратный HTTP-запрос в систему заказов, продолжается бизнес-процесс.
8. **Начинается доставка.**
   Здесь мы имитируем доставку и другие элементы путем ожидания 10 секунд. Этот этап пустой. Затем бизнес-процесс
   приостанавливается, ожидая завершения доставки.
9. **Курьер доставил еду.**
   Заходит в систему и подтверждает окончание доставки. Система курьеров делает обратный HTTP-запрос в систему заказов.
   Бизнес-процесс продолжается.
10. **Финальный шаг.**
    Заказ переводится в статус "доставлен", и бизнес-процесс завершается.

### UI и принципы разделения по доменам

Учитывая полную автономию и независимость наших трех систем,
**мы избегаем использования фреймов или ссылок**,
так как нет необходимости в установлении жестких связей между ними.
Каждая из трех систем эффективно функционирует независимо от других. 

Из-за высокой степени автономии между системами,
**нам не требуется создавать отдельную систему**,
которая бы служила корневой для всех подсистем и
предоставляла бы контент в виде iframe-ов для каждой из них.
Вместо этого мы предпочитаем поддерживать
независимость каждой системы, не нарушая ее автономии.

Такой подход дает нам гибкость и свободу в разработке каждой подсистемы,
а также упрощает управление и поддержку проекта в целом,
поскольку каждая система может эффективно разрабатываться и
внедряться независимо от остальных.

**Для самых любознательных я приведу краткий
пример системы с общим layout-ом в конце статьи.**

### Выбор технологий

<details>
  <summary>Мысли сбежавшего из дурки о выборе технологий</summary>

При выборе технологий для реализации **архитектурного паттерна Self-Contained Systems**
в ~~энтерпрайз-проекте~~ моем демо, учтем не только функциональные требования,
но и особенности объектной области. А у нас есть некоторый функционал, которые можно **решить из коробки**.

В данном случае, я остановился на языке программирования `Java` со `Spring Boot`-ом.
_Но вы думаете что я буду использовать просто Бут будучи разработчиком другого фреймворка?_

Конечно же воспользуемся `Jmix`!

С его помощью мы получаем не только **современный UI**, но и **встроенный движок Bpmn**,
что важно для обеспечения потребностей **бизнес-процессов**.

Дополнительно, `Flowable` используется в качестве `Bpmn 2.0` движка,
предоставляя необходимую **асинхронность** и **отказоустойчивость**,
что является **критическими компонентами** для успешной работы в корпоративной среде.
В контексте **управления пользователями между системами** было принято решение использовать `Keycloak`.
Этот выбор обусловлен не только простотой интеграции,
но и созданием единой точки управления пользователями, что обеспечивает удобство и единообразие.


</details>


#### Итак, технологический стек нашего проекта включает в себя:

- Jmix FlowUI:
    - Spring Boot 3
    - VAADIN 24 (Vaadin Flow)
- Keycloak
- Flowable (в роли Bpmn 2.0 движка для бизнес-процессов + асинхронность)

### Архитектура коммуникаций

Настоятельно рекомендую тщательно ознакомится с тезисами, изложенными ниже, тк они фактически решают 
какие границы ответственности мы используем.

![food-delivery-communication-architecture.png](public/food-delivery-communication-architecture.png)

В данном примере мы сознательно упрощаем сценарий, демонстрируя, 
что для построения устойчивой системы не всегда необходимо использовать
`асинхронные` и/или `реактивные` методы коммуникации.

1. При посещении пользователем страницы заказа мы предоставляем ему все объекты передачи данных (`DTO`), 
полученные из ресторанов. Это гарантирует, что до начала процесса и формирования заказа 
мы не вмешиваемся в консистентность данных. 

    * _Согласно контракту, установленному до момента запроса списка блюд 
    и до его завершения, цены не будут изменяться._
    В начале процесса, когда пользователь еще не создал корзину от нас ничего не требуется.
    * Следовательно, **неблокирующие асинхронные запросы не требуются**, 
    поскольку у пользователя нет объектов для просмотра, и он все равно должен ожидать загрузки данных и 
    отображения элементов меню.

2. При создании заказа пользователем мы **сохраняем копии выбранных им блюд**, обеспечивая, 
таким образом, **надежность** в случае изменения или удаления элементов из меню ресторана.

3. Все взаимодействия остаются внутри процесса. 
С учетом того, что мы пишем процесс с использованием Bpmn 2.0 и движка Flowable,
запросы будут отправляться **асинхронно**.

4. Мы реализуем паттерн **Request-Wait-ResponseAfter** через Flowable:
    - Асинхронно отправляем запрос в другую систему в рамках отдельной задачи в бизнес-процессе.
    - Затем останавливаем процесс на задаче для пользователя, ожидая подтверждения продолжения процесса из другой системы.

При получении ответа от другой системы мы возобновляем пользовательскую задачу, и процесс продолжает свой ход. 
Этот подход решает множество проблем, связанных как с устойчивостью, так и с минимизацией межсистемных коммуникаций.

### Реализация в двух словах
_Изначально статья должна была быть детальной, но если затянуть с объяснением всего, то кажется ее бы можно было
изложить только в 12 часовой видос на youtube или небольшую книгу._ **Потому буду давать фрагменты кода и комментарии.**
Начнем сначала.

#### Создание базового функционала Restaurant System

Нужен **CRUD для ресторанов, еды и меню внутри ресторан**а. Так как мы пишем на Jmix - у нас есть возможность написать **полноценный сайт**, а не 
использовать Rest API и какой-нибудь Postman.

Сущности первой необходимости:
- **Restaurant**
- **RestaurantMenu**
- **RestaurantMenuItem**

Пропущу код связанный с созданием UI, лишь скажу, что мы создали:
- **экран**(да, да, именно экран, так страницы называются в Jmix) **списка ресторанов**
- **экран настройки ресторана для админа**
- **экран ресторана с деталями** (список еды, список меню)
- **экран деталей еды и экран деталей меню**

Прикрутим `Rest` для того, чтобы можно было из системы **Заказов** доставать список ресторанов и их содержимого:
<details>
  <summary>RestaurantController</summary>

```java
@Secured(FullAccessRole.CODE)
@RestController
@RequestMapping(value = "api/v1")
public class RestaurantController {

    private final RestaurantRepository restaurantRepository;
    private final DataManager dataManager;
    private final AttachmentService attachmentService;
    private final FetchPlans fetchPlans;
    private final RestaurantMenuRepository restaurantMenuRepository;

    @GetMapping("/restaurants")
    public List<RestaurantDTO> listRestaurants() {
        return StreamSupport.stream(restaurantRepository.findAll().spliterator(), false)
                .map(restaurant -> {
                    var dto = new RestaurantDTO();
                    dto.setId(restaurant.getId());
                    dto.setName(restaurant.getName());
                    dto.setDescription(restaurant.getDescription());
                    dto.setIcon(attachmentService.getAttachmentAsByteArray(restaurant));
                    return dto;
                })
                .toList();
    }

    @GetMapping("/restaurants/{id}")
    public RestaurantDTO getRestaurant(@PathVariable Long id) {
        Restaurant restaurant = restaurantRepository.getById(id);
        var dto = new RestaurantDTO();
        dto.setId(restaurant.getId());
        dto.setName(restaurant.getName());
        dto.setDescription(restaurant.getDescription());
        dto.setIcon(attachmentService.getAttachmentAsByteArray(restaurant));
        return dto;
    }

    @GetMapping("/restaurants/{restaurantId}/menus")
    public List<RestaurantMenuDTO> listRestaurants(@PathVariable Long restaurantId) {
        return restaurantMenuRepository.findRestaurantMenuByRestaurantId(restaurantId)
                .map(menu -> {
                    var menuDTO = dataManager.create(RestaurantMenuDTO.class);
                    menuDTO.setId(menu.getId());
                    menuDTO.setName(menu.getName());
                    menuDTO.setItems(convertItemsToDTO(menu.getItems()));
                    return menuDTO;
                })
                .toList();
    }
}
```
</details>

Итак, как только **мы написали все необходимые эндпоинты**, можем перейти к **настройке ресторанов**.
**Создадим пару ресторанов и еду в них**, чтобы было с чем работать в системе заказов.

Предлагаю создать **StarBucks**, а то в последнее время его не хватает. _Хотя нет, чего действительно не хватает это **Сбер Пиццы**._
Реализуем же фантазии, кто знает, возможно это станет правдой...

<img alt="restaurants-list.png" height="50%" src="public/restaurants-list.png" width="70%"  style="border: 2px solid  gray; border-radius: 10px;"/>

Заполним рестораны. Остановимся только на сберпицце)

1. Детали </br>
    <img alt="restaurant-detail-1.png" height="30%" src="public/restaurant-detail-1.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>
2. Еда </br>
    <img alt="restaurant-detail-2.png" height="30%" src="public/restaurant-detail-2.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>
3. Меню, они же табы для клиентов </br>
    <img alt="restaurant-detail-3.png" height="30%" src="public/restaurant-detail-3.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>

Думаю со сбера хватит. Переходим к **OrderService**.

На этом этапе нам необходим лишь **функционал создания корзины**, все остальное будет реализовано в следующих шагах с бизнес-процессом.

* Создадим **общий API пакет**, который будет содержать описание всех **REST моделей** (на самом деле он уже есть и все модели выбаются с Rest-а).
* Добавим необходимые сущности для первичной работы с корзиной:
  * **OrderEntity** - сама сущность заказа
  * **RestaurantFoodItemReplica** - реплика еды в текущем состоянии. Не буду слишком долго вдаваться в микросервисные паттерны, но в кратце такие сущности 
  обычно хранятся как json документы, которые **уменьшают нагрузку** и **связность между подсисетмами**. Мы для простоты будем хранить их в ACID в Postgres
  * **FoodItemCountedEntity** - Сущность, которая хранит конкретную еду и счет сколько еды было выбрано
* **Добавим UI для корзины.** Надо будет отобразить список ресторанов на выбор. И тут происходит самое интересное!
_Нам не нужна асинхронность, чтобы отобразить список ресторанов, так как банально юзер и так ждет, пока список загрузится._
Когда загрузятся рестораны, а клиент выберет нужный ресторан, он пойдет в конкретный ресторан и сие действие повториться, но уже для еды и меню.
Давайте посмотрим на клиент для **RestaurantSystem** внутри системы заказов:
    <details>
      <summary>RestaurantClient</summary>
    
    ```java
      @Component
      public class RestaurantClient extends AbstractClient {
    
        public List<RestaurantDTO> listRestaurants(String subjectToken) {
            String url = MessageFormat.format("{0}/api/v1/restaurants", caclRestaurantUrl());
            return getApi(url, HttpMethod.GET, new ParameterizedTypeReference<List<RestaurantDTO>>() {}, null, subjectToken);
        }
    
        public RestaurantDTO getRestaurantById(Long restaurantId, String subjectToken) {
            String url = MessageFormat.format("{0}/api/v1/restaurants/{1,number,#}", caclRestaurantUrl(), restaurantId);
            return getApi(url, HttpMethod.GET, new ParameterizedTypeReference<RestaurantDTO>() {}, null, subjectToken);
        }
    
        public List<RestaurantMenuDTO> listRestaurantMenus(Long restaurantId, String subjectToken) {
            String url = MessageFormat.format("{0}/api/v1/restaurants/{1,number,#}/menus", caclRestaurantUrl(), restaurantId);
            return getApi(url, HttpMethod.GET, new ParameterizedTypeReference<List<RestaurantMenuDTO>>() {}, null, subjectToken);
        }
    }
    ```
    </details>
    
    Опустим лишние детали, нас тут интересует только то, что все **"стартовые"** запросы процесса по доставке еды могут быть синхронные, тк
    используются только на **стороне юзера для UI**.

#### Перейдем к проверке работы корзины, сделаем заказ
1. **Выберем ресторан**. КОНЕЧНО ЖЕ СБЕР ПИЦЦА </br>
   <img alt="order-detail-1.png" height="30%" src="public/order-detail-1.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>
2. **Удостоверимся, что все меню и еда пришла верная** </br>
   <img alt="order-detail-2.png" height="30%" src="public/order-detail-2.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>
3. Соберем инвестиционный портфель. Ой, то есть **соберем корзину еды**, конечно же. </br>
   <img alt="order-detail-3.png" height="30%" src="public/order-detail-3.png" width="60%"  style="border: 2px solid  gray; border-radius: 10px;"/>

Отлично, корзина готова и можно приступать к самому интересному - **бизнес процессу**, который мы обозначили пару топиков назад.

### Бизнес процесс всему голова!

Так как у нас есть `Flowable` и есть **реальный бизнес процесс**, который можно описать, **то построим всю доставку еды на BPMN**:
![order-bpmn.png](public/order-bpmn.png)

Все те же шаги, что и в том красивом бизнес процессе. Осталось дело за малым - привязать все `ServiceTask` (те что с колесиком) к Java коду.

#### Больше деталей: как UserTask решит все мои проблемы
Многие задумались, а как я буду решать проблему, когда возникает **некоторое ожидание**, когда мы ждем **готовку еды** или когда **ищем курьера**?

**И тут самая главная идея BPMN нам помогает**! 

> **UserTask** - это объект нотации bpmn, когда бизнес процесс перестает исполняться и встревает на UserTask в
ожидании, когда таску продолжат. То есть, мы пойдем исполнять по очереди **java код** для каждой сервис таски, **пока не наткнемся на первую UserTask-у**.
Чтобы **"разморозить"** исполнение бизнес процесса, нам понадобиться **специально найти эту таски и сказать "а-ну продолжайся!"**.

_Короткий экскурс в bpmn окончен_. Погнали к делу:

1. Как только наш **заказчик подтвердил свою корзину**, **мы начнем бизнес-процесс** и присвоем ему статус НАШЕЙ КОРЗИНЫ (заказа).
Получается, зная в каком мы инстансе бизнес-процесса, мы знаем и номер заказа. Супер гут.

<img alt="super-good-tinkoff.png" height="30%" src="public/super-good-tinkoff.png" width="30%" style="border: 2px solid  gray; border-radius: 10px;"/>

Остается только **запустить процесс из экрана**, когда **заказчик нажимает кнопку подтверждения**
(я тут нарочно избегаю слово клиент во избежание путаницы со словом SomeHttpClient).
```java
    public ProcessInstance startOrderProcess(String orderId) {
        AppUser appUser = (AppUser) currentAuthentication.getUser();

        Map<String, Object> processVariables = Map.of(
                PROCESS_USER_KEY, appUser.getUsername()
        );
        return runtimeService.startProcessInstanceByKey(ORDER_PROCESS_SCHEMA_ID, orderId, processVariables);
    }

```

И сразу пройдем к первому шагу. **Присваиваем ему статус нового и сохраняем в транзакционный контекст**.

```java
    @Override
    protected void doTransactionalStep(DelegateExecution execution, OrderEntity order, SaveContext saveContext) {
        order.setStatus(DraftOrderStatus.NEW_ORDER);
        saveContext.saving(order);
        doSomeWork();
    }
```

#### Асинхронные ServiceTask и bpmn паттерн **Request-Wait-ResponseAfter**

Далее все наши `ServiceTask` **будут исполняться в отдельных потоках**, будут помечены **асинхронным флагом** и принадлежать к **разным транзакциям**, тем самым
_**мы даем гарантии, что наш когда будет всегда максимально изолирован и устойчив к ошибкам**_. Да, да, бизнес процесс можно еще и откатывать)

Не буду освещать все шаги, так как они **однотипны**, лишь **рассмотрим один общий паттерн**, по которому проходит весь бизнес процесс:
1. Мы делаем Http запрос в **асинхронной** `ServiceTask` в другую систему с запросов "сготовьте еду в таком то ресторане"

    <details>
      <summary>RequestRestaurantCookStep</summary>
   
   ```java
        @Service
        public class RequestRestaurantCookStep extends AbstractTransactionalStep {
            private final Logger log = LoggerFactory.getLogger(RequestRestaurantCookStep.class);
            private final RestaurantClient restaurantClient;
            private final OrderService orderService;
            
            @Override
            protected void doTransactionalStep(DelegateExecution execution, OrderEntity order, SaveContext saveContext) {
                String username = getVariable(execution, PROCESS_USER_KEY);
                String subjectToken = exchangeOidcTokenForUser(username);
                String result = systemAuthenticator.withUser(username,
                        () -> restaurantClient.publishRestaurantCookRequest(order.getRestaurantId(), orderService.convert(order), subjectToken));
                log.info("Result from restaurant system for cook request: " + result);
                order.setStatus(DraftOrderStatus.WAIT_FOR_RESTAURANT);
                saveContext.saving(order);
                doSomeWork();
            }
        }
    ```
    </details>

   <details>
   <summary>RestaurantClient#publishRestaurantCookRequest</summary>
   
   ```java
    public String publishRestaurantCookRequest(Long restaurantId, OrderDTO orderDTO, String subjectToken) {
        String url = MessageFormat.format("{0}/api/v1/restaurants/{1,number,#}/cook", restaurantUrl, restaurantId);
        return getApi(url, HttpMethod.POST, new ParameterizedTypeReference<String>() {}, orderDTO, subjectToken);
    }
    ```
    </details>

2. При обработке запроса на готовку в системе ресторанов **сохраняется запрос** для дальнейшего отображения админам.
   <details>
   <summary>RestaurantController#getRestaurantCookRequest</summary>

   ```java
    @PostMapping("/restaurants/{restaurantId}/cook")
    public String getRestaurantCookRequest(@PathVariable Long restaurantId, @RequestBody OrderDTO orderDTO) {
        cookOrderService.submitNewCookOrderFromDTO(orderDTO);
        // we will not bring case that restaurant will not cook, placeholder response
        return "Accepted";
    }
    ```
    </details>

   <details>
   <summary>CookOrderService#submitNewCookOrderFromDTO</summary>

   ```java
    public void submitNewCookOrderFromDTO(OrderDTO orderDTO) {
   
        var cookOrderRequest = create(CookOrderRequest.class);
        cookOrderRequest.setOrderId(orderDTO.getOriginOrderId());
        cookOrderRequest.setIsDone(false);
        cookOrderRequest.setRestaurant(restaurantRepository.getById(orderDTO.getRestaurantId()));
        cookOrderRequest.setCookingItems(createCookingListFromDTO(cookOrderRequest, orderDTO));
   
        save(cookOrderRequest);
    }
    ```
    </details>
3. Админ ресторана заходит в список задач на готовку, берется за нее, тем самым **отправляет обратный Http запрос** обратно в систему заказов.
    <details>
       <summary>OrderProcessController#continueOrderRestaurantStep</summary>
    
   ```java
        @PostMapping("/orders/{orderId}/restaurantstep/{restaurantId}")
        public void continueOrderRestaurantStep(@PathVariable String orderId, @PathVariable String restaurantId) {
            orderProcessManager.continueProcessByRestaurantStep(orderId, restaurantId);
        }
   ```
    </details>
4. **Когда приходит Http запрос от системы ресторанов (ответ на запрос о готовке) - мы продолжаем наш бизнес-процесс далее**
    <details>
       <summary>OrderProcessManager#continueProcessByRestaurantStep</summary>

   ```java
        public void continueProcessByRestaurantStep(String orderId, String restaurantId) {
            OrderEntity order = orderRepository.getById(Long.parseLong(orderId));
            if (!order.getRestaurantId().toString().equals(restaurantId)) {
                throw new RuntimeException(MessageFormat.format("Illegal access for task(Order No.){0} exception, restaurantId {1}", orderId, restaurantId));
            }
            continueUserTaskInProcess(orderId, "WAIT_RESTAURANT_CALLBACK_TASK");
        }
    
        private void continueUserTaskInProcess(String orderId, String taskDefinitionId) {
            ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()
                    .processInstanceBusinessKey(orderId)
                    .singleResult();
            Task restaurantTask = taskService.createTaskQuery()
                    .processInstanceId(processInstance.getId())
                    .active()
                    .taskDefinitionKey(taskDefinitionId)
                    .singleResult();
            taskService.complete(restaurantTask.getId());
        }
   ```
    </details>
5. СУУУУПЕР ГУД. **Request-Wait-ResponseAfter** реализован в бизнес-процессе. 
6. Далее делаем то же самое для шагов с поиском курьера и **подтверждением окончания доставки от курьера**. 

_Усложнять статью не буду, потому опущу код, связанный с точно такими же шагами с курьером и сервис-тасками, которые просто 
меняют статус заказа._


## Результат демо

!!!!!!!!!!!!!!!!!!!!!!!!Добавить сюда гиффку!

Подведем промежуточные итоги для текущего демо проекта:
1. Мы построили п**роект доставки еды в стиле Self-Contained Systems**;
2. Проект получился весьма **устойчивым к ошибкам**;
3. **Связность** между подсистемами **минимальна**;
4. Большинство **поинтов философии SCS были поддержаны** (в том числе асинхронные и отказоустойчивые коммуникации);
5. **По времени** это заняло **сущие копейки**.

#### А теперь все бежим переписывать наши монолиты на Self-Contained Systems
<br/>
<img alt="tinkoff-sarcasm.png" height="30%" src="public/tinkoff-sarcasm.png" width="30%" style="border: 2px solid  gray; border-radius: 10px;"/>

Но все же! Мы не использовали `iframe` и проект получился **не очень связным в UI** и все связи находятся только на уровне коммуникаций.
Предлагаю вкратце рассмотреть пример, **как можно написать SCS при помощи iframe.**

## Альтернативный вариант Self-Contained Systems через iframe 
Данный вариант построения самодостаточных систем является более **каноничным**, тк на сайте в первых поинтах сразу упоминают iframe. 
**Хоть я и не считаю, что такой подход имеет большой потенциал** (достаточно трудно найти подходящий бизнес-сценарий), **мы обязаны его
рассмотреть.** 

Перейдем на **Amazon.com**, возьмем как пример веб магазина, у которого существует множество поддоменов(подсистем):

1. В меню борде мы видим список разных **ссылок на подсистемы**, которые могут быть реализованы **отдельными "монолитами".**
Их мы и выделим в качестве подсистем. Но для подсистем надо иметь общий layout (common space).
   <br/>
   <img alt="amazon-web.png" height="70%" width="70%" src="public/amazon-web.png" style="border: 2px solid gray; border-radius: 10px;"/>
2. В то время как для контента подсистем надо выделить **большое пространство**, где мы будем **отображать UI выделенной подсистемы**, которую пользователь
выберет
3. Следовательно, **декомпозиция на подсистемы с общей UI системой будет выглядеть примерно так**:
    <br/>
    <img alt="amazon-web-deconstructed.png" height="70%" src="public/amazon-web-deconstructed.png" width="70%" style="border: 2px solid gray; border-radius: 10px;"/>

Что происходит когда пользователь заходит на такой сайт?

1. Загружается страница с **общим layout** и каким-то placeholder контентом по центру, где у нас **пространство iframe**.
Либо мы сразу подгружаем дефолтную подсистему для пользователя в iframe space
2. В меню есть **ссылки** при нажатии на которые мы подменяем iframe-ы, каждый из которых ведет в свою подсистему.
3. При подгрузке iframe так же прокидываются **cookie**, поэтому пользователь, залогинившийся в одну общую систему, считай
залогинился во все.

Пример я взял из [видео-ряда](https://youtu.be/xkQ9VaNTwxM?si=2VijRpPZajt0d3P3) англоязычного [контент-мейкера](https://www.youtube.com/@SoftwareDeveloperDiaries) с ютуба.

## Подведем итоги

* Чуть-чуть углубились в Self-Contained Systems;
* Рассмотрели ~~шизотеорию~~ философию комьюнити;
* Создали демо приложение доставки еды и разобрали альтернативный вариант написания Self-Contained Systems, который
более близок к исходному комьюнити и Innoq;

Надеюсь, я развлек вас сколько-то интересным контентом, знания к знаниям архитектур ПО добавился еще один инструмент. 

<img alt="tinkoff-sinner.png" height="30%" src="public/tinkoff-sinner.png" width="30%" style="border: 2px solid  gray; border-radius: 10px;"/>